<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Banter on Uphouseworks</title>
    <link>https://www.uphouseworks.com/tags/banter/</link>
    <description>Recent content in Banter on Uphouseworks</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Apr 2020 16:02:32 +0100</lastBuildDate>
    
	<atom:link href="https://www.uphouseworks.com/tags/banter/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    
    
    <item>
      <title>Writing a Resume in LaTeX</title>
      <link>https://www.uphouseworks.com/posts/writing-a-resume-in-latex/</link>
      <pubDate>Sun, 21 Nov 2021 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/writing-a-resume-in-latex/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve recently been applying for careers, and have found myself exploring how I could best design my resume in LaTeX. I&amp;rsquo;ve had several years of experience writing technical documents in LaTeX, but none in writing a resume (or a CV for that matter). My first versions were not quite up to par, but it was through repeated iteration and exploration that I&amp;rsquo;ve begun to settle on a design that I&amp;rsquo;m happy with. Here are some points that I would like to share about writing a resume/CV in LaTeX. As a disclaimer my points are not perfect, and I&amp;rsquo;m still discovering new facets to keep in mind.&lt;/p&gt;
&lt;h3 id=&#34;for-starters-why-would-you-want-to-write-your-resume-in-latex&#34;&gt;For starters, why would you want to write your resume in LaTeX?&lt;/h3&gt;
&lt;p&gt;This is a great question to start with, as I don&amp;rsquo;t want to give the impression that LaTeX is somehow the only way to prepare your resume. Clearly, this is not the case, and there are an abundance of sensible alternatives out there to choose from. My personal rationale for picking LaTeX stems from how many other choices I&amp;rsquo;ve used and abandoned over the years. I&amp;rsquo;ve had to rewrite my resumes numerous times over the last 8 years, and everytime I somehow ended up using a different choice. Ranging from Word, Google Docs and even Libre Office. At the time I found these document editors were sufficient, but when I wanted to go back and track revisions it wasn&amp;rsquo;t so clear. Today most document editors should have some form of versioning, but what I was really looking for were notes &amp;amp; annotations. A resume can change widely based on the kind of job or career you&amp;rsquo;re applying for, and having notes to track changes is helpful. Document editors do have these features, but I always found myself wanting to keep the formatting &amp;amp; content notes separate from the final document. To this end, LaTeX fills the requirement nicely. Here are a few other points that come to mind.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.latex-project.org/get/&#34;&gt;Great platform support&lt;/a&gt;, and web support via &lt;a href=&#34;https://www.overleaf.com/&#34;&gt;Overleaf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Ability to build a &lt;a href=&#34;https://www.overleaf.com/learn/latex/How_to_write_a_LaTeX_class_file_and_design_your_own_CV_(Part_1)&#34;&gt;reusable resume/CV class&lt;/a&gt; for usage down the road.&lt;/li&gt;
&lt;li&gt;Can version control cleanly with your favorite VCS, probably &lt;a href=&#34;https://git-scm.com/&#34;&gt;git&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, LaTeX offers a degree of control that is closer to how I write markdown or programs every day. When I work in LaTeX I feel that I can innately follow the notation in this fashion, but this is admittedly a personal bias. Based on what you daily drive for your work, it is likely you will find and cherish a very specific document editor for your uses.&lt;/p&gt;
&lt;h3 id=&#34;what-can-i-use-to-get-started&#34;&gt;What can I use to get started?&lt;/h3&gt;
&lt;p&gt;As mentioned above you can always hop on Overleaf to get started writing your resume. They have excellent documentation as well, in case your LaTeX is a little rusty or if you&amp;rsquo;re venturing out of your experienced area.&lt;/p&gt;
&lt;p&gt;I daily drive on macOS, and have found that &lt;a href=&#34;https://pages.uoregon.edu/koch/texshop/&#34;&gt;TexShop&lt;/a&gt; works great locally. I even used it to write up my thesis earlier this year using a wonderful document class provided from Oregon State University.&lt;/p&gt;
&lt;h3 id=&#34;what-should-i-watch-out-for&#34;&gt;What should I watch out for?&lt;/h3&gt;
&lt;p&gt;This isn&amp;rsquo;t exhaustive, but here are some key elements that caught me while I was writing my resume in LaTeX.&lt;/p&gt;
&lt;h4 id=&#34;make-sure-your-document-dimensions-are-formatted-correctly&#34;&gt;Make sure your document dimensions are formatted correctly.&lt;/h4&gt;
&lt;p&gt;This may seem obvious, but I definitely missed this one the first time around while I was laser focused on content. In particular, &lt;strong&gt;make sure you maintain consistent margins on all sides&lt;/strong&gt;. In general, clean 1 inch margins on all sides is a good choice. However, if you find yourself wanting a little extra space, you can always go for 0.5 inch margins instead. Just be sure to make your choice clear and consistent. If your use case requires you to have a different margin size than either of these, that&amp;rsquo;s perfectly fine, but pay careful attention to making sure this is set correctly. A poorly formatted margin will immediately show up in comparison to other resumes.&lt;/p&gt;
&lt;p&gt;This is where other document editors have an advantage, as most automatically set these margins correctly for you at the start. If you&amp;rsquo;re not sure, you can open up a quick document in Word or Google Docs to check what these default margins are set to. More often than not these tend be 1 inch margins.&lt;/p&gt;
&lt;h4 id=&#34;watch-those-line-numbers&#34;&gt;Watch those line numbers!&lt;/h4&gt;
&lt;p&gt;For a CV, line numbers are sensible, but make sure to &lt;strong&gt;drop the line numbers on your resume&lt;/strong&gt;. It&amp;rsquo;s a small &amp;lsquo;gotcha&amp;rsquo;, but if you&amp;rsquo;re sharing a LaTeX class for your resume and CV it&amp;rsquo;s easy to slip up. This quick mark can help right before your resume document start.&lt;/p&gt;
&lt;code style=&#34;line-height:1.5em&#34;&gt;
&lt;br/&gt;\pagenumbering{gobble}&lt;br/&gt;
&lt;/code&gt;

&lt;h4 id=&#34;choose-your-fonts-carefully&#34;&gt;Choose your font(s) carefully&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.creativelive.com/blog/how-much-does-fonts-matter/&#34;&gt;Picking your font is an important choice&lt;/a&gt;. For some this may be a matter of settling on the default font, but with piles of resumes it&amp;rsquo;s easy for yours to blend into the rest. Picking a good font, or pairing of fonts, can help improve the legibility and presentation of your resume. It can also make your resume stand out visually from others. LaTeX&amp;rsquo;s default font isn&amp;rsquo;t too bad, but I personally have found going with Times is simple and quick to read.&lt;/p&gt;
&lt;code style=&#34;line-height:1.5em&#34;&gt;
&lt;br/&gt;% If ptm is present, you can get Times this way&lt;br/&gt;\renewcommand{\rmdefault}{ptm}&lt;br/&gt;
&lt;/code&gt;

&lt;p&gt;The above can be added before your document start, and will change the serif font in your document to Times New Roman. You can find more detail about this at &lt;a href=&#34;https://www.sascha-frank.com/Fonts/Times_New_Roman.html&#34;&gt;Sacha Frank&amp;rsquo;s page on Times New Roman in LaTeX&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In addition, it&amp;rsquo;s a good idea to pick a pair of fonts that work well together. &lt;a href=&#34;https://www.canva.com/learn/the-ultimate-guide-to-font-pairing/&#34;&gt;There are a variety of pairings that you can use&lt;/a&gt;, but I tend to work with a clear sans-serif font for my headers and serif font for my content. In my recent resume and CV I have found that I have a preference for Helvetica and Times New Roman, but I have changed this many times already, and probably will continue to do so. As you may have noticed, my entire site uses Helvetica, so I am &lt;em&gt;definitely&lt;/em&gt; biased towards it.&lt;/p&gt;
&lt;p&gt;Perhaps most of all, &lt;strong&gt;keep in mind the impression that your font choices create, and whether it matches the desired tone of your document&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;abstract-repeated-definitions&#34;&gt;Abstract Repeated Definitions&lt;/h4&gt;
&lt;p&gt;f you find a number of acronyms or names that you write frequently, you have the option of &lt;strong&gt;defining a new command in latex to abstract the implementation detail away&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Writing C++ in LaTeX is a great example. I missed it numerous times, but simply writing C$++$ drops the ++ slightly below the C, making it a bit awkward (evident here as well). Maybe this was a poor to begin with on my part, but after doing some looking around it appears this has been &lt;a href=&#34;https://tex.stackexchange.com/questions/4302/prettiest-way-to-typeset-c-cplusplus&#34;&gt;a pretty common problem with a variety of solutions&lt;/a&gt;. Regardless of your solution choice, it&amp;rsquo;s often best to implement it as a reusable command.&lt;/p&gt;
&lt;code style=&#34;line-height:1.5em&#34;&gt;
&lt;br/&gt;\newcommand{\cpp}{C\texttt{++}}&lt;br/&gt;...&lt;br/&gt;And did I mention I know \cpp{}?&lt;br/&gt;
&lt;/code&gt;

&lt;p&gt;Again, this was a small change, but I found it to be dramatically better looking on the final result.&lt;/p&gt;
&lt;h4 id=&#34;keep-an-eye-on-your-space&#34;&gt;Keep an eye on your space&lt;/h4&gt;
&lt;p&gt;When writing a resume, &lt;strong&gt;it&amp;rsquo;s in your best interest to take advantage of all the space you have on your page&lt;/strong&gt;. Especially when you have large margins, you want to make sure that you&amp;rsquo;re demonstrating your best self on the limited real estate that you have. To this end, take care about how much trailing space you&amp;rsquo;re leaving behind throughout your document. If you&amp;rsquo;re finding that most of your lines are only half or 3/4 of the available width, maybe it would be best to segment your resume into a new layout with side-by-side sections. Not only can this help fill out some of the extra space on your resume, but it can bring a bit of balance and style to your resume&amp;rsquo;s presentation.&lt;/p&gt;
&lt;h4 id=&#34;dont-be-afraid-to-change-the-layout&#34;&gt;Don&amp;rsquo;t be afraid to change the layout&lt;/h4&gt;
&lt;p&gt;This ties in closely with what was mentioned above, but really don&amp;rsquo;t be worried to push the boundaries of the layout on your resume. Not only is this a learning opportunity, but it&amp;rsquo;s also a chance to create a truly spectacular resume that is, at the same time, clean and clear to your personal identity. Your resume&amp;rsquo;s layout is as much about you as it&amp;rsquo;s content, so make sure to take equal care of it!&lt;/p&gt;
&lt;p&gt;&amp;hellip;And that&amp;rsquo;s about it.&lt;/p&gt;
&lt;p&gt;As a parting note, there are plenty of LaTeX resume/CV templates out there to explore. I&amp;rsquo;ve recently been working with a version of a template that itself was based off of &lt;a href=&#34;https://github.com/deedy/Deedy-Resume&#34;&gt;Deedy&amp;rsquo;s template on Github&lt;/a&gt;, a notably popular choice. As of writing this it hasn&amp;rsquo;t been touched since 2016, but it serves as a nice example for the kind of resume layouts you can build in LaTeX. That, and there&amp;rsquo;s no shortage of forks based on it.&lt;/p&gt;
&lt;p&gt;If you have any questions, or concerns, you can reach me at &lt;a href=&#34;mailto:wilson.f.benjamin@gmail.com&#34;&gt;wilson.f.benjamin@gmail.com&lt;/a&gt;. I&amp;rsquo;m always happy to hear your thoughts, corrections, and suggestions to provide better content for readers like yourself.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Revising the Latria Programming Language</title>
      <link>https://www.uphouseworks.com/posts/revising-the-latria-programming-language/</link>
      <pubDate>Sat, 20 Nov 2021 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/revising-the-latria-programming-language/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Latria is a very small scripting language that I started writing back in 2014, and finished up sometime in 2016. The goal was to see whether or not I could write my own language if I really put my mind to it. In addition, I had recently learned &lt;a href=&#34;https://www.lua.org/&#34;&gt;lua&lt;/a&gt;, and was inspired to write something in a similar vein. It was a vast undertaking at the time, as I had no formal experience writing languages at all (and no programming language theory experience either at that point). It taught me a considerable amount about writing cross platform applications, dealing with stealthy pointer-related bugs, and the fundamentals of garbage collection. Towards the end I pushed myself to write in a simplified regular expression parsing engine, which was sufficient enough to integrate into the parser as well.&lt;/p&gt;
&lt;p&gt;Looking back at it now, it certainly hasn’t aged in the prettiest way. There was a lot I didn’t understand at the time. However, this has had an unexpected fruit to bear. It now provides a wonderful opportunity to go back and revise what I initially wrote to create a better language than before.&lt;/p&gt;
&lt;h3 id=&#34;problems-from-the-old-design&#34;&gt;Problems from the Old Design&lt;/h3&gt;
&lt;p&gt;The first question is, of course, how can I make it better? Well, having authored the language I was acutely aware of some glaring problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no formal semantics&lt;/li&gt;
&lt;li&gt;dynamic scoping instead of static scoping&lt;/li&gt;
&lt;li&gt;problems with the regular expression parsing engine&lt;/li&gt;
&lt;li&gt;inconsistent null comparisons&lt;/li&gt;
&lt;li&gt;issues passing the results of function calls directly as arguments to other functions&lt;/li&gt;
&lt;li&gt;&lt;em&gt;really&lt;/em&gt; tightly coupled lexer and parser&lt;/li&gt;
&lt;li&gt;and more&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;benefits-from-the-old-design&#34;&gt;Benefits from the Old Design&lt;/h3&gt;
&lt;p&gt;Thankfully, there were also some benefits to the design that I went with all those years ago:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;minimal dependencies, making the same code base compile on systems 6 years later with no problems&lt;/li&gt;
&lt;li&gt;minimal size, both of the code base and the produced binary, so there isn’t so much to look over&lt;/li&gt;
&lt;li&gt;documented guide that describes the existing behavior at &lt;a href=&#34;http://latria.uphouseworks.com/Guide/&#34;&gt;latria.uphouseworks.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;integrated unit and functional tests&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;and-what-i-would-like-to-preserve&#34;&gt;And, What I Would Like to Preserve&lt;/h3&gt;
&lt;p&gt;With these pros and cons in mind, there are some aspects I would like to preserve whilst making revisions to the language:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;keeping it in ANSI C as a singular codebase&lt;/li&gt;
&lt;li&gt;maintaining cross platform support for modern Mac, Linux and Windows operating systems (not necessarily in that order)&lt;/li&gt;
&lt;li&gt;retain about the same level of expressiveness, i.e. no adding of additional syntax that needs to have the semantics extended&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As an extra note about cross platform support, the goal with Latria is that it can be pulled down, quickly compiled, and rendered executable in a minute or less on most systems.&lt;/p&gt;
&lt;h3 id=&#34;rework-outline&#34;&gt;Rework Outline&lt;/h3&gt;
&lt;p&gt;With that last point, here is a general outline for the initial steps I will be taking in the rework of Latria.&lt;/p&gt;
&lt;h4 id=&#34;re-familiarize-myself-with-the-codebase&#34;&gt;Re-familiarize myself with the codebase&lt;/h4&gt;
&lt;p&gt;And to also document the general flow. Although I wrote this language myself, it’s been some years since I’ve worked on it, and my initial response is to simply dive in. However, it would be best to survey the general layout of the project again so I can be sure of what I’m working with (or was working with). This is particularly important for any software project. Being well informed about the architectural structure of your project before making changes can limit the number of unintended bugs that you introduce. For those that you do still introduce, it can help you understand why they occur and how they can be fixed.&lt;/p&gt;
&lt;h4 id=&#34;formalize-the-existing-syntax-and-semantics&#34;&gt;Formalize the existing syntax and semantics&lt;/h4&gt;
&lt;p&gt;This point is somewhat connected to the prior one, as it is also a way of understanding the existing codebase. However, formalizing the existing syntax and semantics will inevitably unveil discrepancies in the original language design. It will also give me an idea of what kinds of changes I want to make to the syntax and semantics to closer represent the language that I’m looking for.&lt;/p&gt;
&lt;h4 id=&#34;fix-dynamic-scoping&#34;&gt;Fix dynamic scoping&lt;/h4&gt;
&lt;p&gt;This is the first bug that I would like to tackle, and I would like to do so without revising everything. The purpose of doing this first, as opposed to rewriting the language first, is to get an idea of what it’s like to fix an integrated part of this project. If it’s easy, it could be indicative that it won’t be too bad to migrate things. If it’s difficult, it may suggest that it would be better to rebuild everything from scratch using parts of the old framework.&lt;/p&gt;
&lt;p&gt;I haven’t planned too far past this point, since it will be a litmus test for what comes next. Regardless of how it goes, I will probably spend a bit more time working on other smaller bugs (like function issues) to gradually bite off larger and larger chunks of the language.&lt;/p&gt;
&lt;h3 id=&#34;end-goals&#34;&gt;End Goals&lt;/h3&gt;
&lt;p&gt;As mentioned before, once this whole rework is done, I would like to have both a new and a familiar language. Latria should retain the notions of the original language, whilst also having a more rigorous implementation. The known bugs that I’m dealing with should be factored out, and the new implementation should have a clear syntax &amp;amp; semantics defined for it. I also want to keep the language fast, since that was one of the original goals of Latria to begin with.&lt;/p&gt;
&lt;p&gt;I also want to add in a few new items:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;function composition (inspired by my recent work with Haskell at Oregon State University)&lt;/li&gt;
&lt;li&gt;a Web Assembly implementation, so that Latria can be operated in the browser, independent of a server environment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ultimately I’m very excited to be looking back at this project again! It was originally a very exciting way to test my skills at the time, and I certainly expect it to be the same now; but on a more advanced level. As I start work on components I’ll add my progress to this site as separate posts periodically. Partly for my own reference, but also as resource for others that are interested in this kind of work.&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    <item>
      <title>Functional Domain-Specific Shader Language (FDSSL)</title>
      <link>https://www.uphouseworks.com/posts/fdssl/</link>
      <pubDate>Fri, 25 Jun 2021 13:56:27 +0200</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/fdssl/</guid>
      <description>&lt;p&gt;A coleague and myself have recently undertaken early work on a higher-level shader language that compiles to &lt;a href=&#34;https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language&#34;&gt;OpenGL Shading Language (GLSL)&lt;/a&gt;.
This effort comes from my own personal experience working with GLSL shaders, and witnessing the complexity that they often entail.&lt;/p&gt;
&lt;p&gt;To be frank I thoroughly enjoy working with shaders because of this complexity and the customization it enables, but it is difficult to get new-comers to understand how to work with and debug shaders for the same reasons.
To address this, we wanted to design a language with some simple goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a simplified syntax with regard to GLSL&lt;/li&gt;
&lt;li&gt;a functional paradigm&lt;/li&gt;
&lt;li&gt;support shader composition (effectful sequencing)&lt;/li&gt;
&lt;li&gt;support function composition&lt;/li&gt;
&lt;li&gt;unify vertex and fragment shader workflows into a single script&lt;/li&gt;
&lt;li&gt;enforce strong typing and ensure type safety&lt;/li&gt;
&lt;li&gt;compile to various GLSL versions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our initial efforts produced a workable version of FDSSL, but we still have much we would like to do.
Ultimately, we&amp;rsquo;re hoping that this language provides a way for general necomers to computer graphics (or newcomers from functional languages) to be able to ease into GLSL itself.
If our efforts are effective, we would also like to see how FDSSL could work in practical applications.
Upon completion, we are also thinking about making this tool available online as a &lt;a href=&#34;https://webassembly.org/&#34;&gt;Web Assembly&lt;/a&gt; module.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/montymxb/FDSSL#readme&#34;&gt;FDSSL on Github.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>BoGL: The Board Game Language</title>
      <link>https://www.uphouseworks.com/posts/bogl/</link>
      <pubDate>Tue, 01 Jun 2021 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/bogl/</guid>
      <description>&lt;p&gt;While finishing up my undergrad at Oregon State University myself and a group of students were putting the finishing touches on the Board Game Language (BoGL).
BoGL, our capstone project, is a functional domain-specific programming language geared towards teaching new CS students.
Additionally, the language (as the name implies) is geared towards teaching these concepts through the lens of board games.
This project started around August 2019 and continues today, and working on it has been a wonderful experience!&lt;/p&gt;
&lt;p&gt;By June 2019 we had successfully finished implementing the base language for public use.
However, the circumstances around the world had changed due to the COVID-19 pandemic.
Our original plan was to reach students by deploying BoGL to iPads via a native app.
This already added complexity, but we were also facing a situation where it was uncertain whether students would have access to any particular device to start with.
To address this, and to encompass as many devices as possible, we switched into deploying BoGL through a web application.
We were then able to provide BoGL to students regardless of whether they had access to a computer, tablet, phone, or something else.
So long as they had a relatively recent browser on a web-capable device, they could program with BoGL.&lt;/p&gt;
&lt;p&gt;We were (and still are) extremely proud of this accomplishment, and I was very happy to have been a part of it.
To this day BoGL has been taught in summer camps, middle school classes, an introductory college course, and is likely to continue to expand to more venues in the future.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in learning BoGL, you can follow this &lt;a href=&#34;https://bogl.engr.oregonstate.edu/tutorials/&#34;&gt;link to BoGL Online&lt;/a&gt;. This will take you to the tutorials page, where you get started learning about CS through our language.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re more interested in the development side of things, you can check out the &lt;a href=&#34;https://github.com/ChildsplayOSU/bogl&#34;&gt;BoGL source on Github&lt;/a&gt;. It&amp;rsquo;s written in Haskell, and utilizes several projects to form a singular stack that serves the language. &lt;em&gt;I&amp;rsquo;ll add more about this in later post.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Research: Program-Concept Classifications</title>
      <link>https://www.uphouseworks.com/posts/program-concept-classifications/</link>
      <pubDate>Tue, 01 Jun 2021 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/program-concept-classifications/</guid>
      <description>&lt;p&gt;My MS thesis, &lt;em&gt;Structuring Teachable Knowledge through Program-Concept Classifications&lt;/em&gt;, was finished and defended mid-June 2021.
It was quite a difficult effort, but well worth the time and experience.
I knew when I returned to Oregon State University in January 2018 that I wanted to finish not only my undergrad, but my MS as well.
Earlier in the same year I never would have imagined that I would go back, but I am more than happy that I did.
I already had acquired practical CS engineering experience in the 5 years before, but I was ready to challenge my understanding and to learn more about computer graphics, programming languages, and education.
Having achieved an MS, it&amp;rsquo;s been nice to take some time to reflect back on my work and what I have learned.&lt;/p&gt;
&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;
&lt;p&gt;While working on my thesis I researched heavily into &lt;a href=&#34;https://en.wikipedia.org/wiki/Formal_concept_analysis&#34;&gt;Formal Concept Analysis (FCA)&lt;/a&gt;, a theory that allows describing and classifying objects and their attributes together.
The resulting classifications can be related together in a complete lattice, which has properties that enable clear paths of exploration through those classifications.
The theory itself is a tad dense, but it is sound and clear once understood.
I found it to be effective given the fact we had programs and concepts we wanted to associate to each other, which correlated nicely with FCA&amp;rsquo;s notion of &lt;em&gt;objects&lt;/em&gt; and &lt;em&gt;attributes&lt;/em&gt;.
We wanted to be able to guide the way programs were presented based on the concepts that they entailed.
We also wanted to avoid oversimplifying with a linear order, and to instead provide a series of paths that account for the possible programs and concepts a learner already may understand.
Using FCA was a natural solution to combining programs with their attributes, and it gave us a structure that facilitated multiple paths of exploration.&lt;/p&gt;
&lt;p&gt;Since we were interested in building classifications for the sake of guiding which programs and concepts were presented in what order, Machine Learning techniques could also have been utilized instead of FCA.
Using ML can produce classification systems that work just as well, or better, but they are often not easy to explain or customize.
While ML is not unreasonable for this application, we wanted to produce work that was customizable for a given set of programs and concepts, and could be easily understood in terms of set &amp;amp; lattice theory.
With FCA there are no decision boundaries or weights involved, simply a series of sub-set relations and a directly customizable set of programs and concepts, which better suited our constraints.
With that being said further work on ordering programs through ML techniques is still worthwhile exploring.&lt;/p&gt;
&lt;p&gt;There is much more to detail as to how this program-concept classification technique was developed from FCA, and the rationale as to why.
If you&amp;rsquo;re interested you can read my thesis below, and feel free to jump towards the chapters that are particularly of interest.
As one recommendation, it&amp;rsquo;s helpful to first familiarize yourself with the basics of FCA, as it forms the groundwork of the classification system used in the thesis.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ir.library.oregonstate.edu/concern/graduate_thesis_or_dissertations/tq57nz829&#34;&gt;Thesis: Structuring Teachable Knowledge through Program-Concept Classifications.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Banter</title>
      <link>https://www.uphouseworks.com/posts/banter/</link>
      <pubDate>Wed, 22 Apr 2020 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/banter/</guid>
      <description>&lt;p&gt;This version is the 5th iteration of a tool that I wrote back in 2014, and has come a long way since.
I have always had an interest in visualizing problems, and in particular being able to visualize the way software is structured at rest, and while running.
The general idea of Banter was to produce a mapping of raw data so that a visual understanding could be created in an otherwise opaque system.
Specific categories of files (images, machine code, compressed data, tables, strings, etc.) can be seen and comprehended purely by visual pattern alone.&lt;/p&gt;
&lt;p&gt;I always have fun popping open things to see how they work inside, and Banter was a way for me to perform this in a digital context.
There are numerous interesting observations I have made over the years playing around with this tool, and it has helped to give me a better understanding of machine code per architecture, compressed archives, images, and other structural aspects.
I believe I will come back to this concept later on, but apply it in a more specific context.
Research into software and program visualization has been done in the past, and has had issues with weak adoption in practical applications.
I believe there is something more to be discovered in this field, but I believe it will take more time, and a slightly different perspective.&lt;/p&gt;
&lt;p&gt;You can checkout &lt;a href=&#34;https://github.com/montymxb/banter#readme&#34;&gt;Banter on Github&lt;/a&gt; for yourself if you&amp;rsquo;re interested.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Blind Search in Pacman</title>
      <link>https://www.uphouseworks.com/posts/pacman/</link>
      <pubDate>Mon, 30 Mar 2020 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/pacman/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Various search algorithms that I implemented on a simple HTML5 implementation of Pacman.
I was interested in seeing how various heuristic search techniques would compare against uninformed search approaches.
What was interesting is how quickly a breadth first search can finish a level of Pacman, even if it runs through lives rather quickly.&lt;/p&gt;
&lt;p&gt;Even if it doesn&amp;rsquo;t play as optimally as would be desired, it still plays better than most humans.
In addition, there may be some interesting follow up research with regards to how longevity and survival can factor into using search on Pacman.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.uphouseworks.com/pacman-ai-demo/index.html&#34;&gt;Click here to see the demo of blind-search on pacman, hosted on this site&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For full disclosure I did &lt;em&gt;not&lt;/em&gt; write this implementation of Pacman. Instead, I modified &lt;a href=&#34;https://github.com/luciopanepinto/pacman&#34;&gt;Lucio Panepinto&amp;rsquo;s Pacman in HTML5&lt;/a&gt;, which was excellently done. I was able to take their existing implementation, and integrate an AI player instead of a human one. This took some time, but it was much easier than writing the original game from scratch.&lt;/p&gt;
&lt;p&gt;The setup is intended for desktops, laptops, or other similarly sized screens. The CSS hasn&amp;rsquo;t been modified to behave well on mobile devices. Buttons to change the search technique are located on the left, as well heuristics that can be applied (only to A* and Minimax in this case). Clicking anywhere on the game will start it, and pacman will play without any input from the player. For data collection, there are some brief statistics that are gathered from each run and added to the textarea at the top-left. Admittedly this testing setup is &lt;em&gt;crude&lt;/em&gt;, but the point was to see if this would work, and indeed it does.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested in the source, you can check out &lt;a href=&#34;https://github.com/montymxb/pacman#readme&#34;&gt;Blind Search in Pacman on Github&lt;/a&gt; for implementation specific details.&lt;/p&gt;
&lt;h3 id=&#34;details&#34;&gt;Details&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;This is, more or less, identical to the description on Github for this project.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The project contains a modified codebase for performing research on the domain of Pacman, with a focus on applying Blind and Heuristic search to attempt to produce solutions to levels in realtime.&lt;/p&gt;
&lt;p&gt;Results indicate that BFS with sufficient depth performs well at solving single levels with 3 lives. Also strong indication that heuristics that prioritize distancing from ghosts greatly increase survivability (as to be expected). A* was also attempted as well.&lt;/p&gt;
&lt;p&gt;This paper looks into generating some compound heuristics that combine individual heuristics to attempt to compensate for shortcomings of individual heuristic approaches. Also of interest was adding in heuristics into a compound mix that prioritize better positioning throughout the game, such as by avoiding the far edges of the map or maintaining close distance to the average center of all capsules remaining in the maze.&lt;/p&gt;
&lt;p&gt;Findings can be found &lt;a href=&#34;https://github.com/montymxb/pacman/blob/master/final_project_ben_friedman_531.pdf&#34;&gt;in this course paper&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Fractal Brownian Motion: Terrain Generator</title>
      <link>https://www.uphouseworks.com/posts/fractal-brownian-motion/</link>
      <pubDate>Mon, 30 Mar 2020 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/fractal-brownian-motion/</guid>
      <description>&lt;p&gt;I was playing around with fractal brownian motion (fbm) as a form of generating computer graphics noise.
I implemented a terrain generator based off of fbm for land, water, and clouds.
The generation of the land as a height map from the resulting values came out quite nice, and I was able to generate fairly decent types of terrain in OpenGL Shader Language.
The approach I used allowed me to perform nearly all of the generation for the terrain in shaders, along with the water and clouds.
The water itself was also an interesting experiment. It was a simple &lt;strong&gt;sin&lt;/strong&gt; wave modified with a light dash of fbm to give it an uneven, wavy texture.
The results here were quite surprising in terms of quality, and this is something I will certainly look into down the road.&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://raw.githubusercontent.com/montymxb/FBM_TerrainGenerator/master/submission/island2.gif&#34;
         alt=&#34;A top-down view of the terrain generator. The cloud volume is super-imposed over the landmass, with a separate sheet simulating water below.&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;A top-down view of the terrain generator. The cloud volume is super-imposed over the landmass, with a separate sheet simulating water below.&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The clouds themselves were implemented using fbm as well, but were generated using volumetric ray casting.
This technique allows a ray to be cast through a solid surface, computing the fbm values as the ray moves through the surface.
The result is calculated dynamically, and as the eye position changes, the resulting values computed by the rays change as well.
To the viewer it then appears that a solid surface (such as a cube) is in fact a volume of clouds.
Adding a slight adjustment with regards to time and a flowing volume of clouds was completed.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/montymxb/FBM_TerrrainGenerator#readme&#34;&gt;FBM Terrain Generator on Github.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>HTJSON</title>
      <link>https://www.uphouseworks.com/posts/htjson/</link>
      <pubDate>Wed, 08 Mar 2017 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/htjson/</guid>
      <description>&lt;p&gt;While experimenting with verifying the structure of HTML (from Metatest and Sitecheck before), I went ahead and spent some time to write up a simple parser in php.
This can go through most HTML and convert it into json, which can then be worked on by other programs.&lt;/p&gt;
&lt;p&gt;The plan was to utilize this as a step in later building and processing websites as JSON, and then decoding them back into HTML, but I decided to leave it at this.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/montymxb/HTJSON#readme&#34;&gt;HTJSON on Github.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Working on Parse</title>
      <link>https://www.uphouseworks.com/posts/parse-community/</link>
      <pubDate>Wed, 08 Mar 2017 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/parse-community/</guid>
      <description>&lt;p&gt;After Parse went open source, we had already been using their PHP SDK for some time at Axolsoft, and we had to figure how to handle the migration.&lt;/p&gt;
&lt;p&gt;Over time I ended up working more on the SDK itself, contributing to it, and eventually taking it on as a project of my own.
It was definitely a lot of fun fixing bugs, introducing features, managing PRs, and bringing the test suite up to spec.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/parse-community/parse-php-sdk#readme&#34;&gt;Parse PHP SDK on Github.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Hangman Azul, a Hangman-Style Android App</title>
      <link>https://www.uphouseworks.com/posts/hangmanazul/</link>
      <pubDate>Fri, 15 Jul 2016 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/hangmanazul/</guid>
      <description>&lt;p&gt;After Bit Shooter I wanted to see what it would be like to create an entire application interface purely in OpenGL.
This was probably one of my favorite mobile applications that I built, one which created a fully dynamic interface for a Hangman game.&lt;/p&gt;
&lt;p&gt;In addition, it gave me an excuse to play around with implementing some bluetooth networking code, and it ended up working out quite well.
Creating the animation of the letter tray at the bottom was really pretty neat too.&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <item>
      <title>SiteCheck, an iOS App for Verifying SEO Metatags</title>
      <link>https://www.uphouseworks.com/posts/sitecheck/</link>
      <pubDate>Wed, 13 Jul 2016 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/sitecheck/</guid>
      <description>&lt;p&gt;&lt;em&gt;Update: SiteCheck is no longer currently published on the App Store. This is purely due to me having to focus my time and efforts on other tasks at the moment. If you have questions or concerns about this tool, you can always contact me for more information.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The solution to your SEO needs is here! If you&amp;rsquo;re a fan of checking your site for compatibility with open graph, twitter tags and more, SiteCheck is the app for you.
I&amp;rsquo;ve personally spent quite a lot of time looking for an easy way to validate whether or not my site has the tags I desire. Whether it be specifying an open graph image or making sure my sites show up as beautiful twitter cards with a large feature graphic.
These are all controlled by changing the tags on your site.
It&amp;rsquo;s a relatively straight forward process, but how do we verify we have everything we need?&lt;/p&gt;
&lt;p&gt;This is where SiteCheck comes in.
In a relatively simple fashion you simply enter your url, click a button and look at your results. It&amp;rsquo;s really that easy.
When used with existing tools like &lt;a href=&#34;https://cards-dev.twitter.com/validator&#34;&gt;twitter validator&lt;/a&gt; or the &lt;a href=&#34;https://developers.facebook.com/tools/debug/&#34;&gt;facebook sharing debugger&lt;/a&gt; it works like dynamite.
You can immediately narrow down to what is not present and quickly implement your missing tags.
In this fashion you can quickly achieve compliance with markup across nearly &lt;em&gt;any&lt;/em&gt; site.&lt;/p&gt;
&lt;p&gt;But what about that new standard that just popped up! Suddenly a fixed tool is a bit behind, and noone wants to wait for an app to update to check for new markup.
In fact why not just let users check for &lt;!-- raw HTML omitted --&gt;any&lt;!-- raw HTML omitted --&gt; markup they want, even if it&amp;rsquo;s undocumented.
SiteCheck lets users do just that. By providing your own tests, any user can simply update a test suite and immediately see the results on their next test.
This is just a simple feature, but extremely powerful. Not only can you have multiple test suites that specifically target certain markup types, but you can also show others a targeted test result.
This means, as an SEO or as a web developer, you can quickly show clients or you boss that you&amp;rsquo;re implementing what you was asked, no further questions!&lt;/p&gt;
&lt;p&gt;Not only is this tool extremely effective, but it&amp;rsquo;s also free! Something that is this beneficial should be accessible to the public.
Originally this tool was based off of &lt;a href=&#34;http://uphouseworks.com/Metatest&#34;&gt;Metatest&lt;/a&gt;, a browser based site checking tool from which SiteCheck originated.
Metatest is free for public use as well, and so SiteCheck will adhere to that.&lt;/p&gt;
&lt;p&gt;The final aspect of this tool is that it is intended for &lt;em&gt;all&lt;/em&gt; levels of users.
Whether you&amp;rsquo;re a seasoned developer, a newcomer, or someone who doesn&amp;rsquo;t even know how to code! This tool is for everyone.
Complexity is nonexistant, it is a simple enter and check system. Even the results are neatly spread out in a series of passes or fails.
It is intended to both educate the uninformed and to help guide the veterans.
Nothing beats a simple check and scan method that deterministically indicates whether you&amp;rsquo;ve achieved compliance with the tags you wish to implement.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Metatest, Verify HTML metatags</title>
      <link>https://www.uphouseworks.com/posts/metatest-metatag-verifier/</link>
      <pubDate>Fri, 01 Jul 2016 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/metatest-metatag-verifier/</guid>
      <description>&lt;p&gt;Verified and checked for proper integration of third party tags can greatly enhance posting and sharing on twitter and facebook.&lt;/p&gt;
&lt;p&gt;Metatest was a tool designed to test to apply regular expressions to attempt to parse HTML, which being inherently irregular needed some programming around it to handle some odd cases. The result was an analysis tool that could determine what meta-tags were missing from your site.&lt;/p&gt;
&lt;p&gt;Inadvertently, this also turned out to be a handy approach towards verifying the structure of an HTML document.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.uphouseworks.com/Metatest/&#34;&gt;You can find the original Metatest page here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>The Latria Scripting Language</title>
      <link>https://www.uphouseworks.com/posts/latria/</link>
      <pubDate>Sat, 28 Nov 2015 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/latria/</guid>
      <description>&lt;p&gt;Lately I have been focusing intently on finishing up a little scripting language of my own design, something called &lt;a href=&#34;http://latria.uphouseworks.com&#34;&gt;Latria&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, a little background on why I started this in the first place. Overall, I desired a lightweight, embeddable scripting language. Something with an emphasis on cross language meshing. There are quite a number of loose scripts, programs, etc. that I have written over the years and I desired a way to work with them collectively when I could. Usually this involved writing up bash scripts, batch scripts, lua scripts, or other scripts to mediate between one or more programs or scripts that I had written. Generally this involved capturing input and interpolating it into another program, which took a bit of work and was unsightly at times.&lt;/p&gt;
&lt;p&gt;At one point I had a thought. Wouldn&amp;rsquo;t it be neat if I could just inline the desired functionality from another language, creating a sort of frankenstein script. Something that could execute itself, but could also run other lines of code in other languages. That was when I started writing up Latria over a year ago. Now, with the language nearing completion, I&amp;rsquo;m ready to test it&amp;rsquo;s mettle. It&amp;rsquo;s been a very long process, but here I&amp;rsquo;ll just cover some general goals of the language.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Execute multiple languages inline&lt;/li&gt;
&lt;li&gt;Interpolate values to and from languages&lt;/li&gt;
&lt;li&gt;Be relatively independent of the underlying system&lt;/li&gt;
&lt;li&gt;Be lightweight enough not to be a nuisance to add to an existing project&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.uphouseworks.com/images/article_images/logo.png&#34; alt=&#34;Latria image&#34;&gt;&lt;/p&gt;
&lt;p&gt;In order to achieve those goals I choose to write Latria in ANSI-C (following the C90 standard). It&amp;rsquo;s a bit outdated, but assures some reasonable reverse compatibility with older systems. To achieve cross language execution Latria uses a glorified piping mechanism, which allows embedding of source code from (just about) any another language. When embedding source code the syntax looks a bit like the following.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    //assigns &#39;value&#39; to the result of what is run between ## and #&amp;amp;gt;
    value##
    language specification
    code in another language to run
    #&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Due to the number of variations from language to language source code is required to fit in-between the ## and #&amp;gt; sequences with nothing else on the line (excluding whitespace). The statement as a whole is effectively a multi-line system execute, but allows variables to interpolated via IN{var} in order to dynamically alter the code. The current setup does only allow system execution, but in the future I will most likely create a stronger tie to commonly used languages such as Java, PHP, Python, etc; but for now this syntax is fairly generic, allowing it to work for most of my needs.&lt;/p&gt;
&lt;p&gt;Now during the course of building latria I had constructed a simple syntax-tree interpreter, slightly adhoc. This was slow, but worked. Eventually I migrated this syntax tree into what became the compiler, and created a standalone Virtual Machine to which bytecode could be fed into. The interpreter for the VM accepts Latria bytecode and embedded source code for other languages as plain text, which is executed on the system as mentioned before. The interpreter can also be coupled with the compiler, creating a standalone executable that is capable of both compiling and executing source code. To keep things simple this will be the default build when the language is released. However for embedded systems or size/time sensitive implementations the interpreter and compiler can be built separately. Requiring only that the Latria source code be compiled beforehand in order to run.&lt;/p&gt;
&lt;p&gt;There is quite a lot that I&amp;rsquo;ve packed into this language, while still attempting to keep it simple. It supports basic types of Number (double,float,int), String, Array, File and Boolean values. There is a very basic DFA regex included that I wrote from scratch. It supports most of the basic quantifiers (no backtracking) and has capturing parentheses. It will also support networking for basic server/client systems. Overall the interpreter weighs in at under 100kb, while the interpreter and compiler together are around 150kb. Not too shabby, but this is still pretty fat and I expect some culling before the release will make it a more comfortable fit for embedded systems.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re interested (and when it&amp;rsquo;s released) you can check out the project and download the source code at &lt;a href=&#34;http://latria.uphouseworks.com&#34;&gt;latria.uphouseworks.com&lt;/a&gt;. There is still a lot to attend to but I expect to put up Latria sometime around December 10th. I intend on making Latria opensource for C programmers and others that are interested in enhancing the functionality of the language. Overall with a year&amp;rsquo;s worth of code in it I still expect to see large room for improvement at the least. Languages take years to mature before they are accepted for general use; so take Latria with the consideration that it is still young and has a ways to go. Hopefully it will be something we all can use!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Axolsoft LLC</title>
      <link>https://www.uphouseworks.com/posts/axolsoft/</link>
      <pubDate>Thu, 01 Jan 2015 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/axolsoft/</guid>
      <description>&lt;p&gt;At the beginning of 2015 I started working at a new business called Axolsoft as the Head Software Engineer. I co-founded Axolsoft with partner, and good friend of mine.&lt;/p&gt;
&lt;p&gt;The majority of my work was programmer-centric, involving developing a set of internal tools, several online portals, and when possible automating any standardized procedures. Most of the time I was developing systems with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP / MySQL&lt;/li&gt;
&lt;li&gt;HTML5/CSS/JS&lt;/li&gt;
&lt;li&gt;NGINX&lt;/li&gt;
&lt;li&gt;Stripe &amp;amp; Braintree payments&lt;/li&gt;
&lt;li&gt;Opencart stores&lt;/li&gt;
&lt;li&gt;MyBB Forums&lt;/li&gt;
&lt;li&gt;Mailing Systems leveraging SFP, DKIM, and DMARC for email security&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not to mention that I &lt;em&gt;also designed the logo&lt;/em&gt;. I was, and still am, very happy with it as well. Originally we wanted a logo resembling an &lt;a href=&#34;https://en.wikipedia.org/wiki/Axolotl&#34;&gt;Axolotl&lt;/a&gt;, a fascinating salamander from Mexico. We believed that, like the rare Axolotl, we were creating something special. We of course wanted software as well, so we added on &amp;lsquo;soft&amp;rsquo; afterwards. To be honest, looking back at it (and based on what I&amp;rsquo;ve been told), it does tend to resemble an Eagle more than Axolotl. Still, the imagery was well suited for our work, and for the boldness of starting a small LLC by ourselves.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Floidia, a flowing soundbard app</title>
      <link>https://www.uphouseworks.com/posts/floidia-soundboard/</link>
      <pubDate>Wed, 01 Jan 2014 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/floidia-soundboard/</guid>
      <description>&lt;p&gt;A simple soundboard application, made up of the leftover components from developing BitShooter. Long since defunct now.&lt;/p&gt;
&lt;p&gt;The original idea was to create a &lt;em&gt;flowing&lt;/em&gt; soundboard, one which allowed dynamic tuning of the sound bytes on the fly. Floidia achieved this by a dynamic OpenGL interface, where users could change the pitch and the volume by dragging a virtual audio stream on the screen. A change in color, and speed, would be shown to help the user associate the physical changes with the auditory ones.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.uphouseworks.com/Floidia/&#34;&gt;You can still see the original page for the application here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Bit Shooter</title>
      <link>https://www.uphouseworks.com/posts/bitshooter/</link>
      <pubDate>Tue, 01 Jan 2013 16:02:32 +0100</pubDate>
      
      <guid>https://www.uphouseworks.com/posts/bitshooter/</guid>
      <description>&lt;p&gt;This was my first real foray into programming and developing any kind of application, and it was a really enjoyable one as well! I taught myself Java from near nothing, and flew into more advanced concepts such as OpenGL, OpenAL, and working with multi-threaded code to implement my own physics system.&lt;/p&gt;
&lt;p&gt;After publishing the app on Android I wrote a second, identical version for iOS in Obj-C (before Swift existed). This version leveraged CoreData, OpenGL, and a few other advanced features I never thought I would get to try out. Both apps were on their respective stores for some years before I pulled them both down. This was done due to the lack of time I had to develop them further, to keep them up-to-date, and the notion that I was happy with the work I had done &amp;mdash; and I was ready to move on.&lt;/p&gt;
&lt;p&gt;Notably the components that I wrote in Bit Shooter found their way into &lt;a href=&#34;https://www.uphouseworks.com/posts/hangmanazul/&#34;&gt;Hangman Azul&lt;/a&gt;, &lt;a href=&#34;https://www.uphouseworks.com/posts/floidia/&#34;&gt;Floidia&lt;/a&gt;, and another unpublished game about &lt;em&gt;ants&lt;/em&gt; &amp;mdash; but I&amp;rsquo;m pretty sure I lost the source code to that years ago (sadly).&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.uphouseworks.com/BitShooter/index.html&#34;&gt;You can see the original Bit Shooter app link here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>
